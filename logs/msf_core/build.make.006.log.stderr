In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:326:0[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:23[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:17[m[K:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:[m[K In member function â€˜[01m[Kvoid Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::operator()(Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar*, Index, const LhsScalar*, const RhsScalar*, Index, Index, Index, Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar, Index, Index, Index, Index, RhsScalar*)[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:574:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.initAcc(C3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:575:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.initAcc(C4);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:946:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) R3 = ploadu<ResPacket>(r3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:948:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.acc(C0, alphav, R0);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:951:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.acc(C3, alphav, R3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:953:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Kpstoreu[m[K(r0, R0);
                   [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Geometry:40:0[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:24[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:17[m[K:
/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h: In instantiation of â€˜[01m[KEigen::Quaternion<typename Eigen::internal::traits<T>::Scalar> Eigen::QuaternionBase<Derived>::operator*(const Eigen::QuaternionBase<OtherDerived>&) const [with OtherDerived = Eigen::Quaternion<double>; Derived = Eigen::Quaternion<double>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™:
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:55:41:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:443:63:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                          [01;35m[Kinternal::traits<Derived>::IsAligned && internal[m[K::traits<OtherDerived>::IsAligned>::run(*this, other);
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:443:63:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:23[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:17[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:62:74:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 1, false>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 1, false>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, 4>, 3, 1, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:63:46:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, 1>, 3, 1, false>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, 1>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, 1>, 3, 1, false>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Block<Eigen::Matrix<double, -1, 1>, 3, 1, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:64:46:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::CoeffBasedProduct<const Eigen::Transpose<Eigen::Matrix<double, -1, 4> >, const Eigen::Matrix<double, -1, 1>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Transpose<Eigen::Matrix<double, -1, 4> >, const Eigen::Matrix<double, -1, 1>&, 6>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Transpose<Eigen::Matrix<double, -1, 4> >, const Eigen::Matrix<double, -1, 1>&, 6>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::Transpose<Eigen::Matrix<double, -1, 4> >; RhsNested = const Eigen::Matrix<double, -1, 1>&; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:76:35:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 1>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 1>&, 6>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 1>&, 6>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::Matrix<double, 4, 4>&; RhsNested = const Eigen::Matrix<double, 4, 1>&; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:89:67:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true> >, Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::SwapWrapper<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:375:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&, int) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:475:11:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/msf_types.h:48:71:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::Matrix<double, 4, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:226:7:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::Block<Eigen::Map<const Eigen::Matrix<double, 6, 6> >, 3, 3, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Map<const Eigen::Matrix<double, 6, 6> >, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Map<const Eigen::Matrix<double, 6, 6> >, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::Block<Eigen::Map<const Eigen::Matrix<double, 6, 6> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Map<const Eigen::Matrix<double, 6, 6> >, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Map<const Eigen::Matrix<double, 6, 6> >, 3, 3, false>; _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:69:55:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::Matrix<double, 3, 3> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:69:55:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:40:28:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 4, 4>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256> >, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 4, 4>; Rhs = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 4, 4>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256> >; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 4, 4>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 4, 4>; Rhs = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 1>&, const Eigen::Transpose<Eigen::Matrix<double, 4, 1> >, 256>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:56:44:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 4, 4> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:74:35:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::Matrix<double, 4, 4>&; RhsNested = const Eigen::Matrix<double, 4, 4>&; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::CoeffBasedProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; Rhs = Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >; LhsNested = const Eigen::Matrix<double, 4, 4>&; RhsNested = const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >; int NestingFlags = 6][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >; Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >, 6>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:89:63:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >, 6>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >, 6>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::Matrix<double, 4, 4>&; RhsNested = const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::CoeffBasedProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >, 6>; Rhs = Eigen::Matrix<double, 4, 1>; LhsNested = const Eigen::Matrix<double, 4, 4>&; RhsNested = const Eigen::Matrix<double, 4, 1>&; int NestingFlags = 6][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Transpose<const Eigen::Matrix<double, 4, 4> >, 6>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 1>&, 6>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:89:67:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; BinaryOp = Eigen::internal::scalar_product_op<double, double>; Lhs = Eigen::Matrix<double, 4, 1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_product_op<double, double>; Lhs = Eigen::Matrix<double, 4, 1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:176:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Matrix<double, 4, 1>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:481:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; BinaryOp = Eigen::internal::scalar_product_op<double, double>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_product_op<double, double>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:176:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/SVD/JacobiSVD.h:929:59:[m[K   required from â€˜[01m[KEigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/SVD/JacobiSVD.h:598:14:[m[K   required from â€˜[01m[KEigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:79:74:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::Matrix<double, 3, 1>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:472:8:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::Matrix<double, 3, 1>; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:63:46:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:473:53:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::Matrix<double, 3, 1>; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:63:46:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 4> >; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/SVD/JacobiSVD.h:867:20:[m[K   required from â€˜[01m[KEigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/SVD/JacobiSVD.h:598:14:[m[K   required from â€˜[01m[KEigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:79:74:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, -1, false> >; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/SVD/JacobiSVD.h:873:18:[m[K   required from â€˜[01m[KEigen::JacobiSVD<MatrixType, QRPreconditioner>& Eigen::JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/SVD/JacobiSVD.h:598:14:[m[K   required from â€˜[01m[KEigen::JacobiSVD<MatrixType, QRPreconditioner>::JacobiSVD(const MatrixType&, unsigned int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; int QRPreconditioner = 2; Eigen::JacobiSVD<MatrixType, QRPreconditioner>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:79:74:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:91:15:[m[K   required from â€˜[01m[Kvoid Eigen::MatrixBase<Derived>::makeHouseholder(EssentialPart&, Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) const [with EssentialPart = Eigen::VectorBlock<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:45:18:[m[K   required from â€˜[01m[Kvoid Eigen::MatrixBase<Derived>::makeHouseholderInPlace(Eigen::MatrixBase<Derived>::Scalar&, Eigen::MatrixBase<Derived>::RealScalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>; Eigen::MatrixBase<Derived>::Scalar = double; Eigen::MatrixBase<Derived>::RealScalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:361:5:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:370:25:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:768:16:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::quaternionbase_assign_impl<Other, 4, 1>::run(Eigen::QuaternionBase<OtherDerived>&, const Other&) [with Derived = Eigen::Quaternion<double>; Other = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:516:59:[m[K   required from â€˜[01m[KDerived& Eigen::QuaternionBase<Derived>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:266:72:[m[K   required from â€˜[01m[KEigen::Quaternion<Scalar, Options>::Quaternion(const Eigen::MatrixBase<OtherDerived>&) [with Derived = Eigen::Block<const Eigen::Matrix<double, 4, 4>, 4, 1, true>; _Scalar = double; int _Options = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:71:37:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:768:16:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::quaternionbase_assign_impl<Other, 4, 1>::run(Eigen::QuaternionBase<OtherDerived>&, const Other&) [with Derived = Eigen::Quaternion<double>; Other = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:516:59:[m[K   required from â€˜[01m[KDerived& Eigen::QuaternionBase<Derived>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:266:72:[m[K   required from â€˜[01m[KEigen::Quaternion<Scalar, Options>::Quaternion(const Eigen::MatrixBase<OtherDerived>&) [with Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Options = 0][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:641:12:[m[K   required from â€˜[01m[KEigen::Quaternion<typename Eigen::internal::traits<T>::Scalar> Eigen::QuaternionBase<Derived>::inverse() const [with Derived = Eigen::Quaternion<double>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:55:37:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:768:16:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::quaternionbase_assign_impl<Other, 4, 1>::run(Eigen::QuaternionBase<OtherDerived>&, const Other&) [with Derived = Eigen::Quaternion<double>; Other = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:516:59:[m[K   required from â€˜[01m[KDerived& Eigen::QuaternionBase<Derived>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:266:72:[m[K   required from â€˜[01m[KEigen::Quaternion<Scalar, Options>::Quaternion(const Eigen::MatrixBase<OtherDerived>&) [with Derived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Options = 0][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:645:12:[m[K   required from â€˜[01m[KEigen::Quaternion<typename Eigen::internal::traits<T>::Scalar> Eigen::QuaternionBase<Derived>::inverse() const [with Derived = Eigen::Quaternion<double>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:55:37:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 1, 0, 4, 1>, Eigen::Matrix<double, -1, 1, 0, 4, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:368:35:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>; _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:447:10:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, -1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, -1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, -1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, -1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, -1>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:448:13:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Matrix<double, 4, 4> >, Eigen::Matrix<double, 4, 4, 1, 4, 4> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4, 1, 4, 4>; Derived = Eigen::SwapWrapper<Eigen::Matrix<double, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:384:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(Eigen::PlainObjectBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4, 1, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:805:5:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::matrix_swap_impl<MatrixTypeA, MatrixTypeB, SwapPointers>::run(MatrixTypeA&, MatrixTypeB&) [with MatrixTypeA = Eigen::Matrix<double, 4, 4>; MatrixTypeB = Eigen::Matrix<double, 4, 4, 1, 4, 4>; bool SwapPointers = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:682:81:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4, 1, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:334:7:[m[K   required from â€˜[01m[Kvoid Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::swap(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4, 1, 4, 4>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/TriangularMatrix.h:687:5:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:578:71:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::Matrix<double, 4, 4>, 1>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::Matrix<double, 4, 4>, 1>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<const Eigen::Matrix<double, 4, 4>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:421:7:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:84:5:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:361:5:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:23[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:17[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived2 = Eigen::Matrix<double, -1, 1, 0, 4, 1>; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:368:35:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:23[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:17[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > > >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > > >; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, -1, 1, false> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, -1, 1, false> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/SelfadjointRank2Update.h:32:62:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:372:5:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:43:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:367:35:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/SelfadjointMatrixVector.h:224:46:[m[K   required from â€˜[01m[Kvoid Eigen::SelfadjointProductMatrix<Lhs, LhsMode, false, Rhs, 0, true>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; int LhsMode = 17; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Eigen::SelfadjointProductMatrix<Lhs, LhsMode, false, Rhs, 0, true>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:118:71:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Derived = Eigen::SelfadjointProductMatrix<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 17, false, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >, 0, true>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Eigen::ProductBase<Derived, Lhs, Rhs>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:71:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:367:35:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/SelfadjointMatrixVector.h:233:75:[m[K   required from â€˜[01m[Kvoid Eigen::SelfadjointProductMatrix<Lhs, LhsMode, false, Rhs, 0, true>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; int LhsMode = 17; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Eigen::SelfadjointProductMatrix<Lhs, LhsMode, false, Rhs, 0, true>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:118:71:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Derived = Eigen::SelfadjointProductMatrix<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 17, false, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >, 0, true>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Eigen::ProductBase<Derived, Lhs, Rhs>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:71:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:367:35:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/SelfadjointMatrixVector.h:247:12:[m[K   required from â€˜[01m[Kvoid Eigen::SelfadjointProductMatrix<Lhs, LhsMode, false, Rhs, 0, true>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; int LhsMode = 17; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Eigen::SelfadjointProductMatrix<Lhs, LhsMode, false, Rhs, 0, true>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:118:71:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Block<Eigen::Matrix<double, 3, 1>, -1, 1, false>; Derived = Eigen::SelfadjointProductMatrix<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 17, false, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >, 0, true>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Eigen::ProductBase<Derived, Lhs, Rhs>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:71:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:367:35:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, CoeffVectorType&) [with MatrixType = Eigen::Matrix<double, 4, 4>; CoeffVectorType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:446:31:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false>, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false>, 6>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false>, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/NoAlias.h:41:79:[m[K   required from â€˜[01m[KExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false>, 6>; ExpressionType = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:163:19:[m[K   required from â€˜[01m[Kvoid Eigen::MatrixBase<Derived>::applyHouseholderOnTheRight(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:251:13:[m[K   required from â€˜[01m[Kvoid Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, 4, 4>; Workspace = Eigen::Matrix<double, 4, 1>; VectorsType = Eigen::Matrix<double, 4, 4>; CoeffsType = Eigen::Matrix<double, 3, 1>; int Side = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:231:13:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, Eigen::CoeffBasedProduct<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, 6>; Derived = Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/NoAlias.h:41:79:[m[K   required from â€˜[01m[KExpressionType& Eigen::NoAlias<ExpressionType, StorageBase>::operator=(const StorageBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, 6>; ExpressionType = Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >; StorageBase = Eigen::MatrixBase][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:126:19:[m[K   required from â€˜[01m[Kvoid Eigen::MatrixBase<Derived>::applyHouseholderOnTheLeft(const EssentialPart&, const Scalar&, Eigen::MatrixBase<Derived>::Scalar*) [with EssentialPart = Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Eigen::MatrixBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:254:13:[m[K   required from â€˜[01m[Kvoid Eigen::HouseholderSequence<VectorsType, CoeffsType, Side>::evalTo(Dest&, Workspace&) const [with Dest = Eigen::Matrix<double, 4, 4>; Workspace = Eigen::Matrix<double, 4, 1>; VectorsType = Eigen::Matrix<double, 4, 4>; CoeffsType = Eigen::Matrix<double, 3, 1>; int Side = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:231:13:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0> >; Derived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0> >; Derived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:627:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setOnes() [with Derived = Eigen::Diagonal<Eigen::Matrix<double, 4, 4>, 0>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:245:9:[m[K   [ skipping 5 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, 4, 1, true>, -1, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/HouseholderSequence.h:258:11:[m[K   [ skipping 5 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> >; BinaryOp = Eigen::internal::scalar_product_op<double, double>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_product_op<double, double>, Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_product_op<double, double>; Lhs = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1, 0, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:176:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator*=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:157:11:[m[K   [ skipping 6 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true> >; OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:164:9:[m[K   [ skipping 6 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:165:18:[m[K   [ skipping 6 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false> >; OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >; Rhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:127:9:[m[K   [ skipping 6 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > >; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, 1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Householder/Householder.h:128:18:[m[K   [ skipping 6 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256> >, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256>; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256> >; OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Transpose<const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >, 256>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/NoAlias.h:82:37:[m[K   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256> >, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256>; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256> >; OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>; Rhs = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, -1, 1, 0, 4, 1>, const Eigen::Map<Eigen::Matrix<double, 1, -1, 1, 1, 4>, 0, Eigen::Stride<0, 0> >, 256>; Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 4, 4>, -1, -1, false>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/NoAlias.h:82:37:[m[K   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 1, 0, 4, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 1, 0, 4, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/similaritytransform.h:23[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:17[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived2 = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1, 0, 4, 1>, 0, Eigen::Stride<0, 0> > >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 1, 0, 4, 1>; Derived2 = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; Derived = Eigen::Matrix<double, -1, 1, 0, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<const Eigen::Matrix<double, 4, 4>, -1, 1, false> >; _Scalar = double; int _Rows = -1; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::HouseholderSequence<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 3, 1>, 1>; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:450:11:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::tridiagonalization_inplace_selector<MatrixType, Size, IsComplex>::run(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>; MatrixType = Eigen::Matrix<double, 4, 4>; int Size = 4; bool IsComplex = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/Tridiagonalization.h:430:55:[m[K   required from â€˜[01m[Kvoid Eigen::internal::tridiagonalization_inplace(MatrixType&, DiagonalType&, SubDiagonalType&, bool) [with MatrixType = Eigen::Matrix<double, 4, 4>; DiagonalType = Eigen::Matrix<double, 4, 1>; SubDiagonalType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:426:39:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<MatrixType>& Eigen::SelfAdjointEigenSolver<_MatrixType>::compute(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:161:14:[m[K   required from â€˜[01m[KEigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const MatrixType&, int) [with _MatrixType = Eigen::Matrix<double, 4, 4>; Eigen::SelfAdjointEigenSolver<_MatrixType>::MatrixType = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/similaritytransform.cc:68:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:326:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/msf_tools.h:20[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/msf_tools.cc:17[m[K:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:[m[K In member function â€˜[01m[Kvoid Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::operator()(Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar*, Index, const LhsScalar*, const RhsScalar*, Index, Index, Index, Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar, Index, Index, Index, Index, RhsScalar*)[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:574:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.initAcc(C3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:575:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.initAcc(C4);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:946:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) R3 = ploadu<ResPacket>(r3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:948:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.acc(C0, alphav, R0);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:951:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.acc(C3, alphav, R3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:953:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Kpstoreu[m[K(r0, R0);
                   [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:326:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:21[m[K:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:[m[K In member function â€˜[01m[Kvoid Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::operator()(Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar*, Index, const LhsScalar*, const RhsScalar*, Index, Index, Index, Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar, Index, Index, Index, Index, RhsScalar*)[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:574:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.initAcc(C3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:575:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.initAcc(C4);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:946:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) R3 = ploadu<ResPacket>(r3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:948:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.acc(C0, alphav, R0);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:951:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.acc(C3, alphav, R3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:953:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Kpstoreu[m[K(r0, R0);
                   [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:21[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, 192, 1>, 64, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:148:48:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<int, 192, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<int, 192, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; _Scalar = int; int _Rows = 192; int _Cols = 1; int _Options = 0; int _MaxRows = 192; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:160:58:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<int, 192, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<int, 192, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; _Scalar = int; int _Rows = 192; int _Cols = 1; int _Options = 0; int _MaxRows = 192; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:161:58:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:21[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<int, 192, 1>; Derived2 = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<int, 192, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; _Scalar = int; int _Rows = 192; int _Cols = 1; int _Options = 0; int _MaxRows = 192; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:160:58:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<int, 192, 1>; Derived2 = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<int, 192, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; Derived = Eigen::Matrix<int, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<int>, const Eigen::Matrix<int, 192, 1>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<int>, Eigen::Matrix<int, 192, 1> > >; _Scalar = int; int _Rows = 192; int _Cols = 1; int _Options = 0; int _MaxRows = 192; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:161:58:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:21[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 192, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >; Derived = Eigen::Matrix<double, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >; Derived = Eigen::Matrix<double, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 192, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >; Derived = Eigen::Matrix<double, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >; Derived = Eigen::Matrix<double, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >; Derived = Eigen::Matrix<double, 192, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 192, 1> >; _Scalar = double; int _Rows = 192; int _Cols = 1; int _Options = 0; int _MaxRows = 192; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, 192, 1>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<double, 192, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/falsecolor.cc:142:20:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:326:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/gps_conversion.h:20[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:17[m[K:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:[m[K In member function â€˜[01m[Kvoid Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::operator()(Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar*, Index, const LhsScalar*, const RhsScalar*, Index, Index, Index, Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar, Index, Index, Index, Index, RhsScalar*)[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:574:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.initAcc(C3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:575:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.initAcc(C4);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:946:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) R3 = ploadu<ResPacket>(r3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:948:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.acc(C0, alphav, R0);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:951:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.acc(C3, alphav, R3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:953:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Kpstoreu[m[K(r0, R0);
                   [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/gps_conversion.h:20[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:17[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/include/msf_core/msf_types.h:48:71:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:26:46:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Matrix<double, 3, 1> >, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::SwapWrapper<Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:384:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(Eigen::PlainObjectBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:805:5:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::matrix_swap_impl<MatrixTypeA, MatrixTypeB, SwapPointers>::run(MatrixTypeA&, MatrixTypeB&) [with MatrixTypeA = Eigen::Matrix<double, 3, 1>; MatrixTypeB = Eigen::Matrix<double, 3, 1>; bool SwapPointers = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:682:81:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:334:7:[m[K   required from â€˜[01m[Kvoid Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::swap(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:224:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:55:62:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:85:57:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::Matrix<double, 3, 1>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:472:8:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:85:57:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:473:53:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:85:57:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::Matrix<double, 4, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:156:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:479:12:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>& Eigen::QuaternionBase<Derived>::operator=(const Eigen::QuaternionBase<Derived>&) [with Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:234:3:[m[K   required from â€˜[01m[KEigen::Quaternion<Scalar, Options>& Eigen::Quaternion<Scalar, Options>::operator=(const Eigen::Quaternion<Scalar, Options>&) [with _Scalar = double; int _Options = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/ethzasl_msf/msf_core/src/lib/gps_conversion.cc:53:49:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
