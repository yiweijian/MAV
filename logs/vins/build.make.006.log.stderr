In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:326:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:[m[K In member function â€˜[01m[Kvoid Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::operator()(Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar*, Index, const LhsScalar*, const RhsScalar*, Index, Index, Index, Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar, Index, Index, Index, Index, RhsScalar*)[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:574:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.initAcc(C3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:575:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.initAcc(C4);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:946:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) R3 = ploadu<ResPacket>(r3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:948:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.acc(C0, alphav, R0);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:951:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.acc(C3, alphav, R3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:953:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Kpstoreu[m[K(r0, R0);
                   [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Geometry:40:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:6[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h: In instantiation of â€˜[01m[KEigen::Quaternion<typename Eigen::internal::traits<T>::Scalar> Eigen::QuaternionBase<Derived>::operator*(const Eigen::QuaternionBase<OtherDerived>&) const [with OtherDerived = Eigen::Quaternion<double>; Derived = Eigen::Quaternion<double>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™:
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:74:112:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:443:63:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                          [01;35m[Kinternal::traits<Derived>::IsAligned && internal[m[K::traits<OtherDerived>::IsAligned>::run(*this, other);
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:443:63:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 18, 18, 0, 18, 18>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, 18, 18, 0, 18, 18>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 18, 18, 0, 18, 18>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, 18, 18, 0, 18, 18>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:31:80:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:100:54:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:102:134:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:103:61:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:104:116:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:105:103:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:106:66:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, -1, -1> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:107:69:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:109:127:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:111:109:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:112:96:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:118:78:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:119:109:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:124:71:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> > > >; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:125:102:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:189:110:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> >; Derived = Eigen::Block<Eigen::Matrix<double, 15, 1>, 3, 1, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:190:101:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Matrix<double, 15, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:71:65:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:100:88:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>, Eigen::Matrix<double, 3, 3> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>; OtherDerived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:101:146:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:155:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, Eigen::Matrix<double, 15, 7, 0, 15, 7> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 7, 0, 15, 7>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:112:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:125:103:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:126:70:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>, Eigen::Matrix<double, 3, 3> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:134:159:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:141:97:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, Eigen::Matrix<double, 15, 9, 0, 15, 9> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 9, 0, 15, 9>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:145:52:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>, Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>; OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:161:145:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:176:96:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>, Eigen::Matrix<double, 3, 3> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>; OtherDerived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:105:56:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:106:56:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 4, 4>, 1, 3, false>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Transpose<Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Transpose<Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> > >; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 1, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 1, 3, false>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Transpose<Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Transpose<Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> > >; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 1, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:60:60:[m[K   required from â€˜[01m[Kstatic Eigen::Matrix<typename Derived::Scalar, 4, 4> Utility::Qleft(const Eigen::QuaternionBase<Derived>&) [with Derived = Eigen::Quaternion<double>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:91:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>, Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>; OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 4, 1>, 3, 1, false>; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 1, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:61:40:[m[K   required from â€˜[01m[Kstatic Eigen::Matrix<typename Derived::Scalar, 4, 4> Utility::Qleft(const Eigen::QuaternionBase<Derived>&) [with Derived = Eigen::Quaternion<double>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:91:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:61:83:[m[K   required from â€˜[01m[Kstatic Eigen::Matrix<typename Derived::Scalar, 4, 4> Utility::Qleft(const Eigen::QuaternionBase<Derived>&) [with Derived = Eigen::Quaternion<double>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:91:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> > >, const Eigen::Matrix<double, 3, 3> >; Derived = Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:71:83:[m[K   required from â€˜[01m[Kstatic Eigen::Matrix<typename Derived::Scalar, 4, 4> Utility::Qright(const Eigen::QuaternionBase<Derived>&) [with Derived = Eigen::Quaternion<double>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:128:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::Block<const Eigen::Matrix<double, 3, 3>, 3, 1, true> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 3, 3>, 3, 1, true>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 3, 3>, 3, 1, true>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::Block<const Eigen::Matrix<double, 3, 3>, 3, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 3, 3>, 3, 1, true>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 3, 3>, 3, 1, true>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:77:36:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:77:36:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 3, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 3, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 3, 1> > >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:89:29:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 15>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:27:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 15>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 15> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 15> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 15> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 15> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:27:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:27:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::Matrix<double, 4, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 1>; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:226:7:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:73:53:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:76:53:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:85:39:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, -1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, -1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:99:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, -1, -1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, -1>; OtherDerived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:99:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >; RhsNested = const Eigen::Matrix<double, 3, 3>&; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseUnaryOp.h:68:35:[m[K   required from â€˜[01m[KEigen::CwiseUnaryOp<UnaryOp, MatrixType>::CwiseUnaryOp(const XprType&, const UnaryOp&) [with UnaryOp = Eigen::internal::scalar_multiple_op<double>; XprType = const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:51:10:[m[K   required from â€˜[01m[Kconst ScalarMultipleReturnType Eigen::MatrixBase<Derived>::operator*(const Scalar&) const [with Derived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6>; Eigen::MatrixBase<Derived>::ScalarMultipleReturnType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6> >; typename Eigen::internal::traits<T>::Scalar = double; Eigen::MatrixBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:101:82:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::Matrix<double, 3, 3>&; RhsNested = Eigen::Matrix<double, 3, 3>; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseUnaryOp.h:68:35:[m[K   required from â€˜[01m[KEigen::CwiseUnaryOp<UnaryOp, MatrixType>::CwiseUnaryOp(const XprType&, const UnaryOp&) [with UnaryOp = Eigen::internal::scalar_multiple_op<double>; XprType = const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:51:10:[m[K   required from â€˜[01m[Kconst ScalarMultipleReturnType Eigen::MatrixBase<Derived>::operator*(const Scalar&) const [with Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6>; Eigen::MatrixBase<Derived>::ScalarMultipleReturnType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6> >; typename Eigen::internal::traits<T>::Scalar = double; Eigen::MatrixBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:102:128:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = Eigen::Matrix<double, 3, 3>; RhsNested = const Eigen::Matrix<double, 3, 3>&; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseUnaryOp.h:68:35:[m[K   required from â€˜[01m[KEigen::CwiseUnaryOp<UnaryOp, MatrixType>::CwiseUnaryOp(const XprType&, const UnaryOp&) [with UnaryOp = Eigen::internal::scalar_multiple_op<double>; XprType = const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:51:10:[m[K   required from â€˜[01m[Kconst ScalarMultipleReturnType Eigen::MatrixBase<Derived>::operator*(const Scalar&) const [with Derived = Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6>; Eigen::MatrixBase<Derived>::ScalarMultipleReturnType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6> >; typename Eigen::internal::traits<T>::Scalar = double; Eigen::MatrixBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:119:91:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::Block<Eigen::Matrix<double, 15, 15>, 3, 3, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 3, 3, false>; _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:174:64:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::Matrix<double, 3, 3> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:174:64:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:186:79:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 1>, Eigen::Matrix<double, 15, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 1>; OtherDerived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:194:16:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:326:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:10[m[K:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:[m[K In member function â€˜[01m[Kvoid Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::operator()(Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar*, Index, const LhsScalar*, const RhsScalar*, Index, Index, Index, Eigen::internal::gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjugateLhs, ConjugateRhs>::ResScalar, Index, Index, Index, Index, RhsScalar*)[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:574:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.initAcc(C3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:575:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.initAcc(C4);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:946:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) R3 = ploadu<ResPacket>(r3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:948:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Ktraits[m[K.acc(C0, alphav, R0);
                   [01;36m[K^~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:951:9:[m[K [01;35m[Kwarning: [m[Kthis â€˜[01m[Kif[m[Kâ€™ clause does not guard... [[01;35m[K-Wmisleading-indentation[m[K]
         [01;35m[Kif[m[K(nr==4) traits.acc(C3, alphav, R3);
         [01;35m[K^~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralBlockPanelKernel.h:953:19:[m[K [01;36m[Knote: [m[K...this statement, but the latter is misleadingly indented as if it were guarded by the â€˜[01m[Kif[m[Kâ€™
                   [01;36m[Kpstoreu[m[K(r0, R0);
                   [01;36m[K^~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 15>, Eigen::Matrix<double, 15, 15> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:152:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> > >; Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> > >; Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:98:41:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> > >; Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> > >; Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:124:46:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 4, 4> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 4, 4> >; _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:104:65:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::Matrix<double, 4, 4> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 4, 4>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 4; int _Cols = 4; int _Options = 0; int _MaxRows = 4; int _MaxCols = 4][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:104:65:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:242:73:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:287:75:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:288:116:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, -1>; Derived2 = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, -1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, -1> >; _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:99:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, -1>; Derived2 = Eigen::Matrix<double, -1, -1>; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, -1>; OtherDerived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, -1>; Derived = Eigen::Matrix<double, -1, -1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = -1; int _Options = 0; int _MaxRows = -1; int _MaxCols = -1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:99:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 15, 0, -1, 15>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = 15; int _Options = 0; int _MaxRows = -1; int _MaxCols = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:63:7:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 15, 15>; Derived = Eigen::Matrix<double, -1, -1>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:133:28:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 18, 0, -1, 18>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = 18; int _Options = 0; int _MaxRows = -1; int _MaxCols = 18][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:63:7:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 18, 18, 0, 18, 18>; Derived = Eigen::Matrix<double, -1, -1>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:63:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:26:39:[m[K   required from â€˜[01m[Kstatic Eigen::Quaternion<typename Derived::Scalar> Utility::deltaQ(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:185:86:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Matrix<double, 3, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Matrix<double, 3, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Matrix<double, 3, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:185:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<double, 3, 1>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:27:20:[m[K   required from â€˜[01m[Kstatic Eigen::Quaternion<typename Derived::Scalar> Utility::deltaQ(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:185:86:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../utility/utility.h:26:39:[m[K   required from â€˜[01m[Kstatic Eigen::Quaternion<typename Derived::Scalar> Utility::deltaQ(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>; typename Derived::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:106:146:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 7, 0, 15, 7>, Eigen::Matrix<double, 15, 7, 0, 15, 7> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 7, 0, 15, 7>; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 7, 0, 15, 7>; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>; OtherDerived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 7, 0, 15, 7>; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 15; int _Cols = 7; int _Options = 0; int _MaxRows = 15; int _MaxCols = 7][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:63:7:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >; Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:112:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 9, 0, 15, 9>, Eigen::Matrix<double, 15, 9, 0, 15, 9> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 9, 0, 15, 9>; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 9, 0, 15, 9>; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>; OtherDerived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 9, 0, 15, 9>; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 15; int _Cols = 9; int _Options = 0; int _MaxRows = 15; int _MaxCols = 9][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:63:7:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >; Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:145:52:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 18, 18, 0, 18, 18>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; _Scalar = double; int _Rows = 18; int _Cols = 18; int _Options = 0; int _MaxRows = 18; int _MaxCols = 18][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:30:53:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > > >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:77:73:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:78:45:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::CoeffBasedProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6>; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; LhsNested = const Eigen::Matrix<double, 3, 3>&; RhsNested = Eigen::Matrix<double, 3, 3>; int NestingFlags = 6][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 3, 3> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 3> >, const Eigen::Matrix<double, 3, 3>&, 6>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 3>, 6>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:102:124:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::CoeffBasedProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; Rhs = Eigen::Matrix<double, 3, 3>; LhsNested = Eigen::Matrix<double, 3, 3>; RhsNested = const Eigen::Matrix<double, 3, 3>&; int NestingFlags = 6][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 3, 3>; Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 3> > >; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::CoeffBasedProduct<Eigen::Matrix<double, 3, 3>, const Eigen::Matrix<double, 3, 3>&, 6>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:119:80:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>, Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>; OtherDerived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:564:57:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/MapBase.h:238:39:[m[K   required from â€˜[01m[KDerived& Eigen::MapBase<Derived, 1>::operator=(const Eigen::MapBase<Derived, 1>&) [with Derived = Eigen::Block<Eigen::Matrix<double, -1, -1>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:321:5:[m[K   required from â€˜[01m[KEigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>& Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>::operator=(const Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>&) [with XprType = Eigen::Matrix<double, -1, -1>; int BlockRows = 3; int BlockCols = 3; bool InnerPanel = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:155:5:[m[K   required from â€˜[01m[KEigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>& Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>::operator=(const Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>&) [with XprType = Eigen::Matrix<double, -1, -1>; int BlockRows = 3; int BlockCols = 3; bool InnerPanel = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:110:5:[m[K   required from â€˜[01m[KEigen::Block<XprType, BlockRows, BlockCols, InnerPanel>& Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>::operator=(const Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>&) [with XprType = Eigen::Matrix<double, -1, -1>; int BlockRows = 3; int BlockCols = 3; bool InnerPanel = false][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:121:54:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived2 = Eigen::Matrix<double, -1, 15, 0, -1, 15>; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = 15; int _Options = 0; int _MaxRows = -1; int _MaxCols = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:63:7:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 15, 15>; Derived = Eigen::Matrix<double, -1, -1>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:133:28:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 15>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:635:113:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::true_type&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:133:28:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived2 = Eigen::Matrix<double, -1, 18, 0, -1, 18>; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = -1; int _Cols = 18; int _Options = 0; int _MaxRows = -1; int _MaxCols = 18][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:63:7:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Matrix<double, 18, 18, 0, 18, 18>; Derived = Eigen::Matrix<double, -1, -1>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:63:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:12:86:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:128:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 15>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>, const Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:83:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Matrix<double, 4, 1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Matrix<double, 4, 1>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:185:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Matrix<double, 4, 1>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Dot.h:156:9:[m[K   required from â€˜[01m[Kvoid Eigen::MatrixBase<Derived>::normalize() [with Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:123:29:[m[K   required from â€˜[01m[Kvoid Eigen::QuaternionBase<Derived>::normalize() [with Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:162:27:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:128:35:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > > >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:189:106:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::Matrix<double, 3, 1>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:472:8:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:128:35:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:473:53:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.cpp:128:35:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:191:77:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:197:7:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::operator const PlainObject&() const [with LhsNested = const Eigen::Matrix<double, 4, 4>&; RhsNested = const Eigen::Matrix<double, 4, 4>&; int NestingFlags = 6; Eigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::PlainObject = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:195:66:[m[K   required from â€˜[01m[KEigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess>::BlockImpl_dense(XprType&, Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess>::Index, Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess>::Index) [with XprType = const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; int BlockRows = 3; int BlockCols = 3; bool InnerPanel = false; bool HasDirectAccess = false; Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess>::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:157:106:[m[K   required from â€˜[01m[KEigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>::BlockImpl(XprType&, Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>::Index, Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>::Index) [with XprType = const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; int BlockRows = 3; int BlockCols = 3; bool InnerPanel = false; Eigen::BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Eigen::Dense>::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:124:41:[m[K   required from â€˜[01m[KEigen::Block<XprType, BlockRows, BlockCols, InnerPanel>::Block(XprType&, Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>::Index, Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>::Index) [with XprType = const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>; int BlockRows = 3; int BlockCols = 3; bool InnerPanel = false; Eigen::Block<XprType, BlockRows, BlockCols, InnerPanel>::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/../plugins/BlockMethods.h:261:10:[m[K   required from â€˜[01m[Kconst Eigen::Block<const Derived, CRows, CCols> Eigen::DenseBase<Derived>::bottomRightCorner() const [with int CRows = 3; int CCols = 3; Derived = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:155:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>; _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseUnaryOp.h:68:35:[m[K   required from â€˜[01m[KEigen::CwiseUnaryOp<UnaryOp, MatrixType>::CwiseUnaryOp(const XprType&, const UnaryOp&) [with UnaryOp = Eigen::internal::scalar_opposite_op<double>; XprType = const Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h:44:36:[m[K   required from â€˜[01m[Kconst Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<typename Eigen::internal::traits<T>::Scalar>, const Derived> Eigen::MatrixBase<Derived>::operator-() const [with Derived = Eigen::Block<const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 4, 4>&, const Eigen::Matrix<double, 4, 4>&, 6>, 3, 3, false>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:107:155:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 1, 3>, Eigen::Transpose<const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 1, 3>; OtherDerived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 1; int _Cols = 3; int _Options = 1; int _MaxRows = 1; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/IO.h:245:32:[m[K   required from â€˜[01m[Kstd::ostream& Eigen::operator<<(std::ostream&, const Eigen::DenseBase<Derived>&) [with Derived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; std::ostream = std::basic_ostream<char>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:93:5:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 1, 3>, Eigen::Matrix<double, 1, 3> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 1, 3>; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 1, 3>; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 1, 3>; OtherDerived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 1, 3>; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 1; int _Cols = 3; int _Options = 1; int _MaxRows = 1; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:62:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/IO.h:245:32:[m[K   required from â€˜[01m[Kstd::ostream& Eigen::operator<<(std::ostream&, const Eigen::DenseBase<Derived>&) [with Derived = Eigen::Transpose<const Eigen::Matrix<double, 3, 1> >; std::ostream = std::basic_ostream<char>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:93:5:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 1, 3>, Eigen::Transpose<Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 1, 3>; OtherDerived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 1; int _Cols = 3; int _Options = 1; int _MaxRows = 1; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 1, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/IO.h:245:32:[m[K   required from â€˜[01m[Kstd::ostream& Eigen::operator<<(std::ostream&, const Eigen::DenseBase<Derived>&) [with Derived = Eigen::Transpose<Eigen::Matrix<double, 3, 1> >; std::ostream = std::basic_ostream<char>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:102:13:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/CoeffBasedProduct.h:150:30:[m[K   required from â€˜[01m[KEigen::CoeffBasedProduct<Lhs, Rhs, NestingFlags>::CoeffBasedProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::Matrix<double, 3, 3>; Rhs = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >; LhsNested = const Eigen::Matrix<double, 3, 3>&; RhsNested = Eigen::Matrix<double, 3, 1>; int NestingFlags = 6][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, const Eigen::Matrix<double, 3, 1>&, 6>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 3>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::CoeffBasedProduct<const Eigen::Matrix<double, 3, 3>&, Eigen::Matrix<double, 3, 1>, 6>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:288:94:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, 18, 18, 0, 18, 18>; Derived2 = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; Derived = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 18, 18, 0, 18, 18> >; _Scalar = double; int _Rows = 18; int _Cols = 18; int _Options = 0; int _MaxRows = 18; int _MaxCols = 18][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:30:53:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >, Eigen::Matrix<double, 3, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::Matrix<double, 3, 1>; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >; OtherDerived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 3, 1>, Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 3, 1>; Rhs = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 3, 1>; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:472:8:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:72:62:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1> > >, const Eigen::Matrix<double, 3, 1> >; _Scalar = double; int _Rows = 3; int _Cols = 1; int _Options = 0; int _MaxRows = 3; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:473:53:[m[K   required from â€˜[01m[KEigen::QuaternionBase<Derived>::Vector3 Eigen::QuaternionBase<Derived>::_transformVector(const Vector3&) const [with Derived = Eigen::Quaternion<double>; Eigen::QuaternionBase<Derived>::Vector3 = Eigen::Matrix<double, 3, 1>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:128:32:[m[K   required from â€˜[01m[Kstatic Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::run(const RotationDerived&, const OtherVectorType&) [with RotationDerived = Eigen::Quaternion<double>; OtherVectorType = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Eigen::internal::rotation_base_generic_product_selector<RotationDerived, OtherVectorType, true>::ReturnType = Eigen::Matrix<double, 3, 1>; typename RotationDerived::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/RotationBase.h:72:89:[m[K   required from â€˜[01m[Ktypename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType Eigen::RotationBase<Derived, _Dim>::operator*(const Eigen::EigenBase<OtherDerived>&) const [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1>, const Eigen::Matrix<double, 3, 1> >; Derived = Eigen::Quaternion<double>; int _Dim = 3; typename Eigen::internal::rotation_base_generic_product_selector<Derived, OtherDerived, OtherDerived:: IsVectorAtCompileTime>::ReturnType = Eigen::Matrix<double, 3, 1>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:72:62:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 3, 3>, Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 3, 3>; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; _Scalar = double; int _Rows = 3; int _Cols = 3; int _Options = 0; int _MaxRows = 3; int _MaxCols = 3][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 3, 3>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Block<Eigen::Matrix<double, 4, 4>, 3, 3, false> >, const Eigen::Matrix<double, 3, 3>&, 6>; Derived = Eigen::Block<Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 3, 3, false>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:134:159:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >; BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:185:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:292:21:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::unblocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:304:23:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::blocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:368:68:[m[K   required from â€˜[01m[Kstatic bool Eigen::internal::LLT_Traits<MatrixType, 1>::inplace_decomposition(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:401:42:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, _UpLo>& Eigen::LLT<MatrixType, UpLo>::compute(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:93:14:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, UpLo>::LLT(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >; BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:185:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:292:21:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::unblocked(MatrixType&) [with MatrixType = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:323:24:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::blocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:368:68:[m[K   required from â€˜[01m[Kstatic bool Eigen::internal::LLT_Traits<MatrixType, 1>::inplace_decomposition(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:401:42:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, _UpLo>& Eigen::LLT<MatrixType, UpLo>::compute(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:93:14:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, UpLo>::LLT(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:768:16:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::quaternionbase_assign_impl<Other, 4, 1>::run(Eigen::QuaternionBase<OtherDerived>&, const Other&) [with Derived = Eigen::Quaternion<double>; Other = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:516:59:[m[K   required from â€˜[01m[KDerived& Eigen::QuaternionBase<Derived>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:266:72:[m[K   required from â€˜[01m[KEigen::Quaternion<Scalar, Options>::Quaternion(const Eigen::MatrixBase<OtherDerived>&) [with Derived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_quotient1_op<double>, const Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Options = 0][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:641:12:[m[K   required from â€˜[01m[KEigen::Quaternion<typename Eigen::internal::traits<T>::Scalar> Eigen::QuaternionBase<Derived>::inverse() const [with Derived = Eigen::Quaternion<double>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:189:52:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Matrix<double, 4, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:172:24:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Rows = 4; int _Cols = 1; int _Options = 0; int _MaxRows = 4; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:768:16:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::quaternionbase_assign_impl<Other, 4, 1>::run(Eigen::QuaternionBase<OtherDerived>&, const Other&) [with Derived = Eigen::Quaternion<double>; Other = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:516:59:[m[K   required from â€˜[01m[KDerived& Eigen::QuaternionBase<Derived>::operator=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; Derived = Eigen::Quaternion<double>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:266:72:[m[K   required from â€˜[01m[KEigen::Quaternion<Scalar, Options>::Quaternion(const Eigen::MatrixBase<OtherDerived>&) [with Derived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 1> >; _Scalar = double; int _Options = 0][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Geometry/Quaternion.h:645:12:[m[K   required from â€˜[01m[KEigen::Quaternion<typename Eigen::internal::traits<T>::Scalar> Eigen::QuaternionBase<Derived>::inverse() const [with Derived = Eigen::Quaternion<double>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:189:52:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, 1, -1, false> >, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, 1, -1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, 1, -1, false>; Derived = Eigen::SwapWrapper<Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, 1, -1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:375:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&, int) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, 1, -1, false>; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, 1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:358:9:[m[K   required from â€˜[01m[Kstatic Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::blocked_lu(Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index, Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index, Scalar*, Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index, PivIndex*, PivIndex&, Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index) [with Scalar = double; int StorageOrder = 0; PivIndex = int; Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:387:17:[m[K   required from â€˜[01m[Kvoid Eigen::internal::partial_lu_inplace(MatrixType&, TranspositionType&, typename TranspositionType::Index&) [with MatrixType = Eigen::Matrix<double, 15, 15>; TranspositionType = Eigen::Transpositions<15, 15, int>; typename TranspositionType::Index = int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:408:31:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:487:10:[m[K   required from â€˜[01m[Kconst Eigen::PartialPivLU<Eigen::Matrix<typename Eigen::internal::traits<T>::Scalar, Eigen::internal::traits<T>::RowsAtCompileTime, Eigen::internal::traits<T>::ColsAtCompileTime, (AutoAlign | ((Eigen::internal::traits<T>::Flags & Eigen::RowMajorBit) ? RowMajor :  ColMajor)), Eigen::internal::traits<T>::MaxRowsAtCompileTime, Eigen::internal::traits<T>::MaxColsAtCompileTime> > Eigen::MatrixBase<Derived>::partialPivLu() const [with Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:36:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<int, 15, 1, 0, 15, 1>, Eigen::Matrix<int, 15, 1, 0, 15, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<int, 15, 1, 0, 15, 1>; Derived = Eigen::Matrix<int, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<int, 15, 1, 0, 15, 1>; Derived = Eigen::Matrix<int, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<int, 15, 1, 0, 15, 1>; OtherDerived = Eigen::Matrix<int, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<int, 15, 1, 0, 15, 1>; Derived = Eigen::Matrix<int, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:47:38:[m[K   required from â€˜[01m[Kconst Eigen::PartialPivLU<Eigen::Matrix<typename Eigen::internal::traits<T>::Scalar, Eigen::internal::traits<T>::RowsAtCompileTime, Eigen::internal::traits<T>::ColsAtCompileTime, (AutoAlign | ((Eigen::internal::traits<T>::Flags & Eigen::RowMajorBit) ? RowMajor :  ColMajor)), Eigen::internal::traits<T>::MaxRowsAtCompileTime, Eigen::internal::traits<T>::MaxColsAtCompileTime> > Eigen::MatrixBase<Derived>::partialPivLu() const [with Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:36:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256> >, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256>; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>; Rhs = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256> >; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, 1, false>; Rhs = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, -1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:291:38:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::unblocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:304:23:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::blocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:368:68:[m[K   required from â€˜[01m[Kstatic bool Eigen::internal::LLT_Traits<MatrixType, 1>::inplace_decomposition(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:401:42:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, _UpLo>& Eigen::LLT<MatrixType, UpLo>::compute(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:93:14:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, UpLo>::LLT(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256> >, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256>; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>; Rhs = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256> >; OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256>; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>, Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, 1, false>; Rhs = Eigen::CoeffBasedProduct<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, -1, -1, false>, const Eigen::Transpose<const Eigen::Block<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, 1, -1, false> >, 256>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:291:38:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::unblocked(MatrixType&) [with MatrixType = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:323:24:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::blocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:368:68:[m[K   required from â€˜[01m[Kstatic bool Eigen::internal::LLT_Traits<MatrixType, 1>::inplace_decomposition(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:401:42:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, _UpLo>& Eigen::LLT<MatrixType, UpLo>::compute(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:93:14:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, UpLo>::LLT(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Matrix<double, 15, 15> >, Eigen::Matrix<double, 15, 15, 1, 15, 15> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 15, 1, 15, 15>; Derived = Eigen::SwapWrapper<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:384:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(Eigen::PlainObjectBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 15, 1, 15, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:805:5:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::matrix_swap_impl<MatrixTypeA, MatrixTypeB, SwapPointers>::run(MatrixTypeA&, MatrixTypeB&) [with MatrixTypeA = Eigen::Matrix<double, 15, 15>; MatrixTypeB = Eigen::Matrix<double, 15, 15, 1, 15, 15>; bool SwapPointers = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:682:81:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 15, 1, 15, 15>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:334:7:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:529:101:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::evalTo(ActualDerived&, const ActualOtherDerived&) [with ActualDerived = Eigen::Matrix<double, 15, 15>; ActualOtherDerived = Eigen::TriangularView<Eigen::Transpose<const Eigen::Matrix<double, 15, 15> >, 2>; Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::TriangularView<Eigen::Transpose<const Eigen::Matrix<double, 15, 15> >, 2>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:578:71:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<Eigen::Transpose<const Eigen::Matrix<double, 15, 15> >, 2>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<Eigen::Transpose<const Eigen::Matrix<double, 15, 15> >, 2>; Derived = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<Eigen::Transpose<const Eigen::Matrix<double, 15, 15> >, 2>; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:325:13:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::TriangularView<Eigen::Transpose<const Eigen::Matrix<double, 15, 15> >, 2>; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:152:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, 1, -1, false> >, Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, 1, -1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, 1, -1, false>; Derived = Eigen::SwapWrapper<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, 1, -1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:375:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&, int) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, 1, -1, false>; Derived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, 1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:268:11:[m[K   required from â€˜[01m[Kstatic Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::unblocked_lu(Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::MatrixType&, PivIndex*, PivIndex&) [with Scalar = double; int StorageOrder = 0; PivIndex = int; Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index = long int; Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::MatrixType = Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:314:26:[m[K   required from â€˜[01m[Kstatic Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::blocked_lu(Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index, Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index, Scalar*, Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index, PivIndex*, PivIndex&, Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index) [with Scalar = double; int StorageOrder = 0; PivIndex = int; Eigen::internal::partial_lu_impl<Scalar, StorageOrder, PivIndex>::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:387:17:[m[K   required from â€˜[01m[Kvoid Eigen::internal::partial_lu_inplace(MatrixType&, TranspositionType&, typename TranspositionType::Index&) [with MatrixType = Eigen::Matrix<double, 15, 15>; TranspositionType = Eigen::Transpositions<15, 15, int>; typename TranspositionType::Index = int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:408:31:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:487:10:[m[K   required from â€˜[01m[Kconst Eigen::PartialPivLU<Eigen::Matrix<typename Eigen::internal::traits<T>::Scalar, Eigen::internal::traits<T>::RowsAtCompileTime, Eigen::internal::traits<T>::ColsAtCompileTime, (AutoAlign | ((Eigen::internal::traits<T>::Flags & Eigen::RowMajorBit) ? RowMajor :  ColMajor)), Eigen::internal::traits<T>::MaxRowsAtCompileTime, Eigen::internal::traits<T>::MaxColsAtCompileTime> > Eigen::MatrixBase<Derived>::partialPivLu() const [with Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:36:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>, Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:564:57:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/MapBase.h:238:39:[m[K   required from â€˜[01m[KDerived& Eigen::MapBase<Derived, 1>::operator=(const Eigen::MapBase<Derived, 1>&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:321:5:[m[K   required from â€˜[01m[KEigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>& Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>::operator=(const Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>&) [with XprType = Eigen::Matrix<double, 15, 15>; int BlockRows = -1; int BlockCols = -1; bool InnerPanel = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:155:5:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SolveTriangular.h:189:11:[m[K   required from â€˜[01m[Kvoid Eigen::TriangularView<MatrixType, Mode>::solveInPlace(const Eigen::MatrixBase<OtherDerived>&) const [with int Side = 2; OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; _MatrixType = const Eigen::Transpose<const Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false> >; unsigned int _Mode = 2][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:324:16:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::blocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:368:68:[m[K   required from â€˜[01m[Kstatic bool Eigen::internal::LLT_Traits<MatrixType, 1>::inplace_decomposition(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:401:42:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, _UpLo>& Eigen::LLT<MatrixType, UpLo>::compute(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:93:14:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, UpLo>::LLT(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:329:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixVector.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::general_matrix_vector_product<Index, LhsScalar, 0, ConjugateLhs, RhsScalar, ConjugateRhs, Version>::run(Index, Index, const LhsScalar*, Index, const RhsScalar*, Index, Eigen::internal::general_matrix_vector_product<Index, LhsScalar, 0, ConjugateLhs, RhsScalar, ConjugateRhs, Version>::ResScalar*, Index, RhsScalar) [with Index = long int; LhsScalar = double; bool ConjugateLhs = false; RhsScalar = double; bool ConjugateRhs = false; int Version = 0; Eigen::internal::general_matrix_vector_product<Index, LhsScalar, 0, ConjugateLhs, RhsScalar, ConjugateRhs, Version>::ResScalar = double][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:460:110:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::gemv_selector<2, 0, true>::run(const ProductType&, Dest&, const typename ProductType::Scalar&) [with ProductType = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Dest = Eigen::Matrix<double, 15, 1>; typename ProductType::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:344:92:[m[K   required from â€˜[01m[Kvoid Eigen::GeneralProduct<Lhs, Rhs, 4>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Matrix<double, 15, 1>; Lhs = Eigen::Matrix<double, 15, 15>; Rhs = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; Eigen::GeneralProduct<Lhs, Rhs, 4>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:118:71:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Matrix<double, 15, 1>; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Lhs = Eigen::Matrix<double, 15, 15>; Rhs = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; Eigen::ProductBase<Derived, Lhs, Rhs>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:71:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 1>; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Lhs = Eigen::Matrix<double, 15, 15>; Rhs = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:284:3:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::lazyAssign(const Eigen::ProductBase<ProductDerived, Lhs, Rhs>&) [with ProductDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Lhs = Eigen::Matrix<double, 15, 15>; Rhs = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixVector.h:145:33:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
   Index offset1 = ([01;35m[KFirstAligned && alignmentStep==1[m[K?3:1);
                    [01;35m[K~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixVector.h:146:33:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
   Index offset3 = ([01;35m[KFirstAligned && alignmentStep==1[m[K?1:3);
                    [01;35m[K~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 15, 0, -1, 15>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:43:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:127:7:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::operator const PlainObject&() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 15, 15>; Eigen::ProductBase<Derived, Lhs, Rhs>::PlainObject = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:98:34:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::ProductBase(const Lhs&, const Rhs&) [with Derived = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>; Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixMatrix.h:393:66:[m[K   required from â€˜[01m[KEigen::GeneralProduct<Lhs, Rhs, 5>::GeneralProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:55:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, -1, 18, 0, -1, 18>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:43:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:127:7:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::operator const PlainObject&() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 18, 18, 0, 18, 18>; Eigen::ProductBase<Derived, Lhs, Rhs>::PlainObject = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:98:34:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::ProductBase(const Lhs&, const Rhs&) [with Derived = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>; Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixMatrix.h:393:66:[m[K   required from â€˜[01m[KEigen::GeneralProduct<Lhs, Rhs, 5>::GeneralProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:83:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived2 = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 15, 0, -1, 15> >; Derived = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:43:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, -1, 15, 0, -1, 15>; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:127:7:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::operator const PlainObject&() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 15, 15>; Eigen::ProductBase<Derived, Lhs, Rhs>::PlainObject = Eigen::Matrix<double, -1, 15, 0, -1, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:98:34:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::ProductBase(const Lhs&, const Rhs&) [with Derived = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>; Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixMatrix.h:393:66:[m[K   required from â€˜[01m[KEigen::GeneralProduct<Lhs, Rhs, 5>::GeneralProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 15, 15>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:55:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived2 = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 18, 0, -1, 18> >; Derived = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:109:43:[m[K   required from â€˜[01m[Kvoid Eigen::ProductBase<Derived, Lhs, Rhs>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, -1, 18, 0, -1, 18>; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 18, 18, 0, 18, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:127:7:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::operator const PlainObject&() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Lhs = Eigen::Matrix<double, -1, -1>; Rhs = Eigen::Matrix<double, 18, 18, 0, 18, 18>; Eigen::ProductBase<Derived, Lhs, Rhs>::PlainObject = Eigen::Matrix<double, -1, 18, 0, -1, 18>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:98:34:[m[K   required from â€˜[01m[KEigen::ProductBase<Derived, Lhs, Rhs>::ProductBase(const Lhs&, const Rhs&) [with Derived = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>; Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/GeneralMatrixMatrix.h:393:66:[m[K   required from â€˜[01m[KEigen::GeneralProduct<Lhs, Rhs, 5>::GeneralProduct(const Lhs&, const Rhs&) [with Lhs = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; Rhs = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:593:60:[m[K   required from â€˜[01m[Kconst typename Eigen::ProductReturnType<Derived, OtherDerived>::Type Eigen::MatrixBase<Derived>::operator*(const Eigen::MatrixBase<OtherDerived>&) const [with OtherDerived = Eigen::Transpose<Eigen::Matrix<double, -1, -1> >; Derived = Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>; typename Eigen::ProductReturnType<Derived, OtherDerived>::Type = Eigen::GeneralProduct<Eigen::GeneralProduct<Eigen::Matrix<double, -1, -1>, Eigen::Matrix<double, 18, 18, 0, 18, 18>, 5>, Eigen::Transpose<Eigen::Matrix<double, -1, -1> >, 5>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/integration_base.h:134:83:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_quotient_op<double, double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_quotient_op<double, double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false>; Rhs = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, -1, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:185:7:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::operator/=(const Scalar&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:274:31:[m[K   [ skipping 5 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:487:10:[m[K   required from â€˜[01m[Kconst Eigen::PartialPivLU<Eigen::Matrix<typename Eigen::internal::traits<T>::Scalar, Eigen::internal::traits<T>::RowsAtCompileTime, Eigen::internal::traits<T>::ColsAtCompileTime, (AutoAlign | ((Eigen::internal::traits<T>::Flags & Eigen::RowMajorBit) ? RowMajor :  ColMajor)), Eigen::internal::traits<T>::MaxRowsAtCompileTime, Eigen::internal::traits<T>::MaxColsAtCompileTime> > Eigen::MatrixBase<Derived>::partialPivLu() const [with Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:36:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >, Eigen::Matrix<double, 15, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 15, 1>; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:456:48:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::gemv_selector<2, 0, true>::run(const ProductType&, Dest&, const typename ProductType::Scalar&) [with ProductType = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Dest = Eigen::Matrix<double, 15, 1>; typename ProductType::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:344:92:[m[K   required from â€˜[01m[Kvoid Eigen::GeneralProduct<Lhs, Rhs, 4>::scaleAndAddTo(Dest&, const Scalar&) const [with Dest = Eigen::Matrix<double, 15, 1>; Lhs = Eigen::Matrix<double, 15, 15>; Rhs = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; Eigen::GeneralProduct<Lhs, Rhs, 4>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ProductBase.h:118:71:[m[K   [ skipping 5 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 4, 4>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 4, 4>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 4, 4> >; Derived = Eigen::Matrix<double, 4, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/products/SelfadjointProduct.h:116:62:[m[K   required from â€˜[01m[KEigen::SelfAdjointView<MatrixType, UpLo>& Eigen::SelfAdjointView<MatrixType, Mode>::rankUpdate(const Eigen::MatrixBase<OtherDerived>&, const Scalar&) [with DerivedU = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; MatrixType = Eigen::Block<Eigen::Matrix<double, 15, 15>, -1, -1, false>; unsigned int UpLo = 1; Eigen::SelfAdjointView<MatrixType, Mode>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:325:16:[m[K   required from â€˜[01m[Kstatic typename MatrixType::Index Eigen::internal::llt_inplace<Scalar, 1>::blocked(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; Scalar = double; typename MatrixType::Index = long int][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:368:68:[m[K   required from â€˜[01m[Kstatic bool Eigen::internal::LLT_Traits<MatrixType, 1>::inplace_decomposition(MatrixType&) [with MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:401:42:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, _UpLo>& Eigen::LLT<MatrixType, UpLo>::compute(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Cholesky/LLT.h:93:14:[m[K   required from â€˜[01m[KEigen::LLT<MatrixType, UpLo>::LLT(const MatrixType&) [with _MatrixType = Eigen::Matrix<double, 15, 15>; int _UpLo = 1; Eigen::LLT<MatrixType, UpLo>::MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:452:9:[m[K   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:54:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                        && [01;35m[K(DstIsAligned || MaxSizeAtCompileTime == Dynamic)[m[K,
                           [01;35m[K~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:96:50:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
                 ? ( bool(MayUnrollCompletely) && [01;35m[Kbool(DstIsAligned)[m[K ? int(CompleteUnrolling) : int(NoUnrolling) )
                                                  [01;35m[K^~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 15, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 15, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 15, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, Eigen::Matrix<double, 15, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_sum_op<double>; Lhs = Eigen::Matrix<double, 15, 1>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:224:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator+=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:470:14:[m[K   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>; Derived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>; OtherDerived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:564:57:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::MatrixBase<Derived>&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/MapBase.h:238:39:[m[K   required from â€˜[01m[KDerived& Eigen::MapBase<Derived, 1>::operator=(const Eigen::MapBase<Derived, 1>&) [with Derived = Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:321:5:[m[K   required from â€˜[01m[KEigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>& Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>::operator=(const Eigen::internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel, true>&) [with XprType = Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>; int BlockRows = -1; int BlockCols = -1; bool InnerPanel = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Block.h:155:5:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:487:10:[m[K   required from â€˜[01m[Kconst Eigen::PartialPivLU<Eigen::Matrix<typename Eigen::internal::traits<T>::Scalar, Eigen::internal::traits<T>::RowsAtCompileTime, Eigen::internal::traits<T>::ColsAtCompileTime, (AutoAlign | ((Eigen::internal::traits<T>::Flags & Eigen::RowMajorBit) ? RowMajor :  ColMajor)), Eigen::internal::traits<T>::MaxRowsAtCompileTime, Eigen::internal::traits<T>::MaxColsAtCompileTime> > Eigen::MatrixBase<Derived>::partialPivLu() const [with Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:36:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 1> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 1> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 1> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 1> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstatic void Eigen::internal::assign_impl<Derived1, Derived2, 3, 0, Version>::run(Derived1&, const Derived2&) [with Derived1 = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived2 = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; int Version = 0][m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:507:85:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >; Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:452:9:[m[K   [ skipping 7 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:402:79:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     const Index alignedStart = [01;35m[Kassign_traits<Derived1,Derived2>::DstIsAligned ? 0[m[K
                                [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~[m[K
 [01;35m[K                             : internal::first_aligned(&dst.coeffRef(0), size)[m[K;
                              [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K 
In file included from [01m[K/usr/local/include/eigen3/Eigen/Core:284:0[m[K,
                 from [01m[K/usr/local/include/eigen3/Eigen/Dense:1[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/CameraPoseVisualization.h:16[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.h:26[m[K,
                 from [01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:10[m[K:
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 7, 0, 15, 7>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 7, 0, 15, 7> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 7, 0, 15, 7> >; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 7, 0, 15, 7> >; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 7, 0, 15, 7> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 7, 0, 15, 7> >; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 7, 0, 15, 7> >; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>; Derived = Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>; _Scalar = double; int _Rows = 15; int _Cols = 7; int _Options = 0; int _MaxRows = 15; int _MaxCols = 7][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 7, 0, 15, 7>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >, 5>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 7, 1> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:112:47:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 9, 0, 15, 9>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 9, 0, 15, 9> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 9, 0, 15, 9> >; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 9, 0, 15, 9> >; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 9, 0, 15, 9> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 9, 0, 15, 9> >; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 15, 9, 0, 15, 9> >; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>; Derived = Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>; _Scalar = double; int _Rows = 15; int _Cols = 9; int _Options = 0; int _MaxRows = 15; int _MaxCols = 9][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 9, 0, 15, 9>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >, 5>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 9, 1> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:145:52:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 7, 1>, Eigen::Matrix<double, 7, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 7, 1>; Derived = Eigen::Matrix<double, 7, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 7, 1>; Derived = Eigen::Matrix<double, 7, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 7, 1>; OtherDerived = Eigen::Matrix<double, 7, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 7, 1>; Derived = Eigen::Matrix<double, 7, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:303:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&) [with _Scalar = double; int _Rows = 7; int _Cols = 1; int _Options = 0; int _MaxRows = 7; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/include/c++/7/bits/stl_pair.h:303:17:[m[K   [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/include/c++/7/bits/stl_tree.h:495:3:[m[K   required from â€˜[01m[Kstd::_Rb_tree_node<_Val>* std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Reuse_or_alloc_node::operator()(_Arg&&) [with _Arg = const std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >&; _Key = int; _Val = std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >; _KeyOfValue = std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >*][m[Kâ€™
[01m[K/usr/include/c++/7/bits/stl_tree.h:666:33:[m[K   required from â€˜[01m[Kstd::_Rb_tree_node<_Val>* std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_clone_node(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type, _NodeGen&) [with _NodeGen = std::_Rb_tree<int, std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >, std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >, std::less<int>, std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > > >::_Reuse_or_alloc_node; _Key = int; _Val = std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >; _KeyOfValue = std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >*; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >*][m[Kâ€™
[01m[K/usr/include/c++/7/bits/stl_tree.h:1818:34:[m[K   required from â€˜[01m[Kstd::_Rb_tree_node<_Val>* std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_copy(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type, std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr, _NodeGen&) [with _NodeGen = std::_Rb_tree<int, std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >, std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >, std::less<int>, std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > > >::_Reuse_or_alloc_node; _Key = int; _Val = std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >; _KeyOfValue = std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >*; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Const_Link_type = const std::_Rb_tree_node<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >*; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Base_ptr = std::_Rb_tree_node_base*][m[Kâ€™
[01m[K/usr/include/c++/7/bits/stl_tree.h:875:31:[m[K   required from â€˜[01m[Kstd::_Rb_tree_node<_Val>* std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_copy(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, _NodeGen&) [with _NodeGen = std::_Rb_tree<int, std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >, std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >, std::less<int>, std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > > >::_Reuse_or_alloc_node; _Key = int; _Val = std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >; _KeyOfValue = std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_Link_type = std::_Rb_tree_node<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >*][m[Kâ€™
[01m[K/usr/include/c++/7/bits/stl_tree.h:1726:25:[m[K   required from â€˜[01m[Kstd::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::operator=(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&) [with _Key = int; _Val = std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > >; _KeyOfValue = std::_Select1st<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >; _Compare = std::less<int>; _Alloc = std::allocator<std::pair<const int, std::vector<std::pair<int, Eigen::Matrix<double, 7, 1> > > > >][m[Kâ€™
[01m[K/usr/include/c++/7/bits/stl_map.h:99:11:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, -1, 1, true>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> > >, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:137:64:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with RhsDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> >; BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, -1, 1, true>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, -1, 1, true>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> > >; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::SelfCwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, -1, 1, true>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/SelfCwiseBinaryOp.h:150:29:[m[K   required from â€˜[01m[KEigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>& Eigen::SelfCwiseBinaryOp<BinOp, Lhs, Rhs>::operator=(const Rhs&) [with BinaryOp = Eigen::internal::scalar_difference_op<double>; Lhs = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, -1, 1, true>; Rhs = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseBinaryOp.h:210:7:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator-=(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, 1, true>, -1, 1, false> >; Derived = Eigen::Block<Eigen::Block<Eigen::Block<Eigen::Map<Eigen::Matrix<double, -1, -1>, 0, Eigen::Stride<0, 0> >, -1, -1, false>, -1, -1, false>, -1, 1, true>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/GeneralProduct.h:268:137:[m[K   [ skipping 9 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/LU/PartialPivLU.h:487:10:[m[K   required from â€˜[01m[Kconst Eigen::PartialPivLU<Eigen::Matrix<typename Eigen::internal::traits<T>::Scalar, Eigen::internal::traits<T>::RowsAtCompileTime, Eigen::internal::traits<T>::ColsAtCompileTime, (AutoAlign | ((Eigen::internal::traits<T>::Flags & Eigen::RowMajorBit) ? RowMajor :  ColMajor)), Eigen::internal::traits<T>::MaxRowsAtCompileTime, Eigen::internal::traits<T>::MaxColsAtCompileTime> > Eigen::MatrixBase<Derived>::partialPivLu() const [with Derived = Eigen::Matrix<double, 15, 15>; typename Eigen::internal::traits<T>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:36:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false> >, Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>; Derived = Eigen::SwapWrapper<Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:375:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(const Eigen::DenseBase<OtherDerived>&, int) [with OtherDerived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>; Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PermutationMatrix.h:609:19:[m[K   required from â€˜[01m[Kvoid Eigen::internal::permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; PermutationType = Eigen::PermutationMatrix<15, 15, int>; MatrixType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >; int Side = 1; bool Transposed = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::permut_matrix_product_retval<Eigen::PermutationMatrix<15, 15, int>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:529:101:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::evalTo(ActualDerived&, const ActualOtherDerived&) [with ActualDerived = Eigen::Matrix<double, 15, 15>; ActualOtherDerived = Eigen::ReturnByValue<Eigen::internal::permut_matrix_product_retval<Eigen::PermutationMatrix<15, 15, int>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, false> >; Derived = Eigen::Matrix<double, 15, 15>; OtherDerived = Eigen::internal::permut_matrix_product_retval<Eigen::PermutationMatrix<15, 15, int>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:585:71:[m[K   [ skipping 9 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:190:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double, 15, 15> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> > >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:12:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 15, 1>, Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 15, 1>; OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::Map<Eigen::Matrix<double, -1, 1>, 1, Eigen::Stride<0, 0> >; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 9 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:296:25:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; _Scalar = double; int _Rows = 15; int _Cols = 1; int _Options = 0; int _MaxRows = 15; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:365:48:[m[K   required from â€˜[01m[KEigen::DenseBase<Derived>::EvalReturnType Eigen::DenseBase<Derived>::eval() const [with Derived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Eigen::DenseBase<Derived>::EvalReturnType = const Eigen::Matrix<double, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:533:120:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, true, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::GeneralProduct<Eigen::Matrix<double, 15, 15>, Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >, 4>; Derived = Eigen::Map<Eigen::Matrix<double, 15, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:75:32:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>, Eigen::Block<const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, 15, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, 15, false>; Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>; OtherDerived = Eigen::Block<const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, 15, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, 15, false>; Derived = Eigen::Block<Eigen::Matrix<double, 15, 15>, 1, 15, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PermutationMatrix.h:625:11:[m[K   required from â€˜[01m[Kvoid Eigen::internal::permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; PermutationType = Eigen::PermutationMatrix<15, 15, int>; MatrixType = Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >; int Side = 1; bool Transposed = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::permut_matrix_product_retval<Eigen::PermutationMatrix<15, 15, int>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> >, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:529:101:[m[K   [ skipping 10 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:190:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double, 15, 15> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> > >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:12:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<bool, 15, 1, 0, 15, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, 15, 1, 0, 15, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, 15, 1, 0, 15, 1> >; Derived = Eigen::Matrix<bool, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, 15, 1, 0, 15, 1> >; Derived = Eigen::Matrix<bool, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<bool, 15, 1, 0, 15, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, 15, 1, 0, 15, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, 15, 1, 0, 15, 1> >; Derived = Eigen::Matrix<bool, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<bool>, Eigen::Matrix<bool, 15, 1, 0, 15, 1> >; Derived = Eigen::Matrix<bool, 15, 1, 0, 15, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 16 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:190:29:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::solve_retval_base<Eigen::PartialPivLU<Eigen::Matrix<double, 15, 15> >, Eigen::CwiseNullaryOp<Eigen::internal::scalar_identity_op<double>, Eigen::Matrix<double, 15, 15> > >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:26:12:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::compute_inverse<MatrixType, ResultType, Size>::run(const MatrixType&, ResultType&) [with MatrixType = Eigen::Matrix<double, 15, 15>; ResultType = Eigen::Matrix<double, 15, 15>; int Size = 15][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/LU/Inverse.h:296:56:[m[K   required from â€˜[01m[Kvoid Eigen::internal::inverse_impl<MatrixType>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; MatrixType = Eigen::Matrix<double, 15, 15>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/ReturnByValue.h:61:7:[m[K   required from â€˜[01m[Kvoid Eigen::ReturnByValue<Derived>::evalTo(Dest&) const [with Dest = Eigen::Matrix<double, 15, 15>; Derived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:311:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(const Eigen::ReturnByValue<OtherDerived>&) [with OtherDerived = Eigen::internal::inverse_impl<Eigen::Matrix<double, 15, 15> >; _Scalar = double; int _Rows = 15; int _Cols = 15; int _Options = 0; int _MaxRows = 15; int _MaxCols = 15][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/../factor/imu_factor.h:73:130:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 4, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 4, 1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 4, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 4, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 4, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 4, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 4, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 4, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:196:57:[m[K   required from â€˜[01m[Kvoid ceres::internal::Take1stOrderPart(int, const JetT*, T*) [with JetT = ceres::Jet<double, 10>; T = double; int N0 = 0; int N = 4][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:299:5:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 3, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 3, 1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 3, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 3, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 3, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 3, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 3, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 3, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:196:57:[m[K   required from â€˜[01m[Kvoid ceres::internal::Take1stOrderPart(int, const JetT*, T*) [with JetT = ceres::Jet<double, 10>; T = double; int N0 = 4; int N = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:300:5:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Map<Eigen::Matrix<double, 0, 1, 0, 0, 1>, 0, Eigen::Stride<0, 0> >, Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 0, 1, false> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 0, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 0, 1, 0, 0, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Map<Eigen::Matrix<double, 0, 1, 0, 0, 1>, 0, Eigen::Stride<0, 0> >; OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 0, 1, false>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Block<const Eigen::Matrix<double, 10, 1, 2, 10, 1>, 0, 1, false>; Derived = Eigen::Map<Eigen::Matrix<double, 0, 1, 0, 0, 1>, 0, Eigen::Stride<0, 0> >][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:196:57:[m[K   required from â€˜[01m[Kvoid ceres::internal::Take1stOrderPart(int, const JetT*, T*) [with JetT = ceres::Jet<double, 10>; T = double; int N0 = 10; int N = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:302:5:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::Matrix<double, 10, 1, 2, 10, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:220:27:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::Matrix(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 10; int _Cols = 1; int _Options = 2; int _MaxRows = 10; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/ceres/jet.h:172:8:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::SwapWrapper<Eigen::Matrix<double, 10, 1, 2, 10, 1> >, Eigen::Matrix<double, 10, 1, 2, 10, 1> >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Derived = Eigen::SwapWrapper<Eigen::Matrix<double, 10, 1, 2, 10, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/DenseBase.h:384:7:[m[K   required from â€˜[01m[Kvoid Eigen::DenseBase<Derived>::swap(Eigen::PlainObjectBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:805:5:[m[K   required from â€˜[01m[Kstatic void Eigen::internal::matrix_swap_impl<MatrixTypeA, MatrixTypeB, SwapPointers>::run(MatrixTypeA&, MatrixTypeB&) [with MatrixTypeA = Eigen::Matrix<double, 10, 1, 2, 10, 1>; MatrixTypeB = Eigen::Matrix<double, 10, 1, 2, 10, 1>; bool SwapPointers = false][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:682:81:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_swap(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:334:7:[m[K   required from â€˜[01m[Kvoid Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::swap(const Eigen::MatrixBase<OtherDerived>&) [with OtherDerived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; _Scalar = double; int _Rows = 10; int _Cols = 1; int _Options = 2; int _MaxRows = 10; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:224:7:[m[K   required from â€˜[01m[KEigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::operator=(Eigen::Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>&&) [with _Scalar = double; int _Rows = 10; int _Cols = 1; int _Options = 2; int _MaxRows = 10; int _MaxCols = 1][m[Kâ€™
[01m[K/usr/local/include/ceres/jet.h:172:8:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 10, 1, 2, 10, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 10, 1, 2, 10, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:653:72:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::_set_noalias(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:638:114:[m[K   required from â€˜[01m[Kvoid Eigen::PlainObjectBase<Derived>::_set_selector(const OtherDerived&, const Eigen::internal::false_type&) [with OtherDerived = Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<double>, Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:630:20:[m[K   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:334:20:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setConstant(const Scalar&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; Eigen::DenseBase<Derived>::Scalar = double][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/CwiseNullaryOp.h:501:21:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::setZero() [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:174:5:[m[K   required from â€˜[01m[Kvoid ceres::internal::Make1stOrderPerturbation(int, const T*, JetT*) [with JetT = ceres::Jet<double, 10>; T = double; int N = 4][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:269:5:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/ceres/jet.h:335:10:[m[K   required from â€˜[01m[Kceres::Jet<T, N> ceres::operator/(const ceres::Jet<T, N>&, const ceres::Jet<T, N>&) [with T = double; int N = 10][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/initial_sfm.h:48:15:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   [ skipping 3 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/ceres/jet.h:288:10:[m[K   required from â€˜[01m[Kceres::Jet<T, N> ceres::operator-(const ceres::Jet<T, N>&, const ceres::Jet<T, N>&) [with T = double; int N = 10][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/initial_sfm.h:50:24:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/ceres/rotation.h:528:36:[m[K   required from â€˜[01m[Kvoid ceres::QuaternionRotatePoint(const T*, const T*, T*) [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/initial_sfm.h:46:31:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/ceres/rotation.h:528:43:[m[K   required from â€˜[01m[Kvoid ceres::QuaternionRotatePoint(const T*, const T*, T*) [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/initial_sfm.h:46:31:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   [ skipping 4 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/ceres/rotation.h:528:30:[m[K   required from â€˜[01m[Kvoid ceres::QuaternionRotatePoint(const T*, const T*, T*) [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/initial_sfm.h:46:31:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
/usr/local/include/eigen3/Eigen/src/Core/Assign.h: In instantiation of â€˜[01m[Kstruct Eigen::internal::assign_traits<Eigen::Matrix<double, 10, 1, 2, 10, 1>, Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> > >[m[Kâ€™:
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:506:64:[m[K   required from â€˜[01m[KDerived& Eigen::DenseBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:414:30:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::lazyAssign(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:527:123:[m[K   required from â€˜[01m[Kstatic Derived& Eigen::internal::assign_selector<Derived, OtherDerived, false, false>::run(Derived&, const OtherDerived&) [with Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>; OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:571:62:[m[K   required from â€˜[01m[KDerived& Eigen::MatrixBase<Derived>::operator=(const Eigen::DenseBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/PlainObjectBase.h:483:22:[m[K   required from â€˜[01m[KDerived& Eigen::PlainObjectBase<Derived>::operator=(const Eigen::EigenBase<OtherDerived>&) [with OtherDerived = Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 10, 1, 2, 10, 1> >; Derived = Eigen::Matrix<double, 10, 1, 2, 10, 1>][m[Kâ€™
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Matrix.h:184:29:[m[K   [ skipping 5 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
[01m[K/usr/local/include/ceres/rotation.h:541:28:[m[K   required from â€˜[01m[Kvoid ceres::QuaternionRotatePoint(const T*, const T*, T*) [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/../estimator/../initial/initial_sfm.h:46:31:[m[K   required from â€˜[01m[Kbool ReprojectionError3D::operator()(const T*, const T*, const T*, T*) const [with T = ceres::Jet<double, 10>][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/variadic_evaluate.h:156:19:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::VariadicEvaluate<Functor, T, N0, N1, N2, 0, 0, 0, 0, 0, 0, 0>::Call(const Functor&, const T* const*, T*) [with Functor = ReprojectionError3D; T = ceres::Jet<double, 10>; int N0 = 4; int N1 = 3; int N2 = 3][m[Kâ€™
[01m[K/usr/local/include/ceres/internal/autodiff.h:282:72:[m[K   required from â€˜[01m[Kstatic bool ceres::internal::AutoDiff<Functor, T, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Differentiate(const Functor&, const T* const*, int, T*, T**) [with Functor = ReprojectionError3D; T = double; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/usr/local/include/ceres/autodiff_cost_function.h:211:66:[m[K   required from â€˜[01m[Kbool ceres::AutoDiffCostFunction<CostFunctor, kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9>::Evaluate(const double* const*, double*, double**) const [with CostFunctor = ReprojectionError3D; int kNumResiduals = 2; int N0 = 4; int N1 = 3; int N2 = 3; int N3 = 0; int N4 = 0; int N5 = 0; int N6 = 0; int N7 = 0; int N8 = 0; int N9 = 0][m[Kâ€™
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/utility/visualization.cpp:437:1:[m[K   required from here
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:53:57:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MayLinearVectorize = [01;35m[KMightVectorize && MayLinearize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/usr/local/include/eigen3/Eigen/src/Core/Assign.h:57:41:[m[K [01;35m[Kwarning: [m[Kenum constant in boolean context [[01;35m[K-Wint-in-bool-context[m[K]
     MaySliceVectorize  = [01;35m[KMightVectorize && DstHasDirectAccess[m[K
                          [01;35m[K~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/KITTIGPSTest.cpp:[m[K In function â€˜[01m[Kint main(int, char**)[m[Kâ€™:
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/KITTIGPSTest.cpp:144:10:[m[K [01;35m[Kwarning: [m[Kignoring return value of â€˜[01m[Kint fscanf(FILE*, const char*, ...)[m[Kâ€™, declared with attribute warn_unused_result [[01;35m[K-Wunused-result[m[K]
    [01;35m[Kfscanf(GPSFile, "%lf %lf %lf %lf %lf %lf ", &lat, &lon, &alt, &roll, &pitch, &yaw)[m[K;
    [01;35m[K~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/KITTIGPSTest.cpp:146:10:[m[K [01;35m[Kwarning: [m[Kignoring return value of â€˜[01m[Kint fscanf(FILE*, const char*, ...)[m[Kâ€™, declared with attribute warn_unused_result [[01;35m[K-Wunused-result[m[K]
    [01;35m[Kfscanf(GPSFile, "%lf %lf %lf %lf %lf ", &vn, &ve, &vf, &vl, &vu)[m[K;
    [01;35m[K~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/KITTIGPSTest.cpp:148:10:[m[K [01;35m[Kwarning: [m[Kignoring return value of â€˜[01m[Kint fscanf(FILE*, const char*, ...)[m[Kâ€™, declared with attribute warn_unused_result [[01;35m[K-Wunused-result[m[K]
    [01;35m[Kfscanf(GPSFile, "%lf %lf %lf %lf %lf %lf ", &ax, &ay, &az, &af, &al, &au)[m[K;
    [01;35m[K~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/KITTIGPSTest.cpp:150:10:[m[K [01;35m[Kwarning: [m[Kignoring return value of â€˜[01m[Kint fscanf(FILE*, const char*, ...)[m[Kâ€™, declared with attribute warn_unused_result [[01;35m[K-Wunused-result[m[K]
    [01;35m[Kfscanf(GPSFile, "%lf %lf %lf %lf %lf %lf ", &wx, &wy, &wz, &wf, &wl, &wu)[m[K;
    [01;35m[K~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
[01m[K/home/nuc/yi/vins/vins_catkin_ws/src/VINS-Fusion/vins_estimator/src/KITTIGPSTest.cpp:152:10:[m[K [01;35m[Kwarning: [m[Kignoring return value of â€˜[01m[Kint fscanf(FILE*, const char*, ...)[m[Kâ€™, declared with attribute warn_unused_result [[01;35m[K-Wunused-result[m[K]
    [01;35m[Kfscanf(GPSFile, "%lf %lf %lf %lf %lf %lf ", &pos_accuracy, &vel_accuracy, &navstat, &numsats, &velmode, &orimode)[m[K;
    [01;35m[K~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
